<h1 id="risc-v-isa-formal-specification-sail-model">RISC-V ISA Formal Specification: Sail Model</h1>
<h2 id="name">Name</h2>
<p>Sail RISC-V model</p>
<h2 id="authors-with-institutions">Authors (with institutions)</h2>
<p>Prashanth Mundkur, SRI International; Jon French, University of Cambridge; Brian Campbell, University of Edinburgh; Robert Norton, University of Cambridge; Alasdair Armstrong, University of Cambridge; Thomas Bauereiss, University of Cambridge; Shaked Flur, University of Cambridge; Peter Sewell, University of Cambridge</p>
<h2 id="spec-sources-snapshot-e.g.-url-to-github-repo">Spec sources snapshot (e.g. URL to github repo)</h2>
<h2 id="spec-sources-live-development-e.g.-url-to-github-repo">Spec sources live development (e.g. URL to github repo)</h2>
<p><a href="https://github.com/rems-project/sail-riscv"><code class="url">https://github.com/rems-project/sail-riscv</code></a></p>
<h2 id="licence">Licence</h2>
<p>BSD two-clause</p>
<h2 id="metalanguage-including-brief-explanation-of-the-metalanguage-used">Metalanguage (including brief explanation of the metalanguage used)</h2>
<p>This ISA specification is written in <a href="https://www.cl.cam.ac.uk/~pes20/sail/">Sail</a>.</p>
<p>Sail is a language for describing the instruction-set architecture (ISA) semantics of processors, in an engineer-friendly, vendor-pseudocode-like style. Sail is essentially a first-order imperative language, but with lightweight dependent types (automatically checked using Z3) for the bitvector lengths and integer ranges that are pervasive in ISA specifications. Given a Sail definition, the tool will type-check it and generate executable emulators, in C and OCaml, theorem-prover definitions for Isabelle, HOL4, and Coq, and definitions to integrate with our <a href="http://www.cl.cam.ac.uk/users/pes20/rmem">RMEM</a> tool for concurrency semantics.</p>
<div class="figure">
<img src="http://www.cl.cam.ac.uk/users/pes20/sail/overview-sail.png" alt="Sail overview" /><p class="caption">Sail overview</p>
</div>
<h2 id="dependencies-on-what-tools">Dependencies on what tools</h2>
<p>Sail is available as pre-built binaries via OPAM, as a source package, and as source in a github repository, BSD licenced. It depends on OCaml, OPAM, libgmp-dev, Z3, Lem, and Ott.</p>
<h2 id="tool-ecosystem-what-other-work-has-beenis-being-done-with-those-tools">Tool ecosystem: what other work has been/is being done with those tools</h2>
<p>Sail is being used for multiple ISA descriptions, including essentially complete versions of the sequential behaviour of ARMv8.5-A (automatically derived from the authoritative ARM-internal specification, and released under a BSD Clear licence with ARM's permission), RISC-V, MIPS, and CHERI-MIPS; all these are complete enough to boot various operating systems. There are also Sail models for smaller fragments of IBM POWER and x86.</p>
<p>Sail is being used:</p>
<ul>
<li>as an ISA design tool for CHERI, both as an executable reference model and for the pseudocode in the CHERI ISA manual</li>
<li>to make theorem-prover ISA definitions available, for multiple architectures and targetting multiple theorem provers</li>
<li>to support work on architecture concurrency models</li>
</ul>
<h2 id="motivation-a-few-sentences-explaining-for-what-the-authors-have-developed-this-spec">Motivation (a few sentences explaining for what the authors have developed this spec)</h2>
<p>The Sail RISC-V ISA model has been developed:</p>
<ul>
<li>as a basis for the design of a CHERI variant of RISC-V, incorporating hardware support for fine-grain memory protection and secure encapsulation.</li>
<li>to support our work on the RISC-V concurrency architecture, providing the ISA semantics required by our <a href="http://www.cl.cam.ac.uk/users/pes20/rmem">RMEM</a> tool for concurrency semantics, which lets one compute all the concurrency-model-allowed behaviours of small litmus tests or ELF binaries.</li>
<li>to provide theorem-prover definitions of the RISC-V ISA, for multiple provers</li>
<li>to support the automatic generation of instruction tests</li>
<li>to use as a test oracle in tandem verification</li>
<li>to provide readable pseudocode that could be used in the RISC-V ISA specification</li>
</ul>
<h2 id="current-functional-coverage-whats-modelled-now-in-risc-v-code-and-in-english">Current functional coverage (what's modelled now, in RISC-V code and in English)</h2>
<ul>
<li><p>The model covers RV64 IMAC (base 64-bit integer, with the standard multiply/divide, atomic, and compressed extensions), M/S/U (machine, supervisor and user privilege) modes, and Sv39-mode (39-bit virtual addressing) address translation.</p></li>
<li><p>The model supports parameterization for platform-specific implementation choices.</p></li>
<li><p>The model does not currently cover RV32 and RV128, the Sv32 and Sv48 address translation modes, floating-point for the F and D standard extensions, encodings for HINT instructions, PMP/PMA physical memory attributes and protection, event and performance counter support, the N standard extension, the hypervisor mode for virtualization, and other extensions such as the vector and bit-manipulation extensions.</p></li>
</ul>
<h2 id="current-specification-of-assembly-syntax-and-encoding">Current specification of assembly syntax and encoding</h2>
<p>The model includes an executable specification of the assembly language encoder/decoder.</p>
<h2 id="current-treatment-of-concurrency">Current treatment of concurrency</h2>
<p>The ISA model is integrated with the operational model of the RISC-V relaxed memory model, RVWMO (as described in an appendix of the <a href="https://github.com/riscv/riscv-isa-manual/releases/tag/draft-20181227-c6741cb">RISC-V user-level specification</a>), which is one of the reference models used in the development of the RISC-V concurrency architecture; this is part of our <a href="http://www.cl.cam.ac.uk/users/pes20/rmem">RMEM</a> tool.</p>
<h2 id="current-treatment-of-floating-point">Current treatment of floating-point</h2>
<p>The Sail RISC-V model does not currently support floating point. We plan to add this over the next few months, at least for some of the Sail emulator and theorem-prover targets.</p>
<h2 id="current-capabilities-what-the-specification-and-associated-tooling-generates-and-enables">Current capabilities (what the specification and associated tooling generates and enables)</h2>
<h3 id="emulation">Emulation</h3>
<p>The model provides OCaml and C emulators that can execute RISC-V ELF files, and both emulators provide platform support sufficient to boot Linux, FreeBSD and seL4. The OCaml emulator can generate its own platform device-tree description, while the C emulator currently requires a consistent description to be manually provided. The C emulator can be linked against the Spike emulator for execution with per-instruction tandem-verification.</p>
<p>The C emulator, for the Linux boot, currently runs at approximately 300000 IPS on an Intel i7-7700 (when detailed per-instruction tracing is disabled), and there are many opportunities for future optimisation (our Sail MIPS model runs at approximately 1 MIPS). This enables us to boot Linux in about 4 minutes, and FreeBSD in about 2 minutes. Memory usage for the C emulator when booting Linux is approximately 140MB.</p>
<h3 id="use-as-test-oracle-in-tandem-verification">Use as test oracle in tandem verification</h3>
<p>For tandem verification of random instruction streams we support the protocols used in <a href="https://github.com/CTSRD-CHERI/TestRIG">TestRIG</a> to directly inject instructions into the C emulator and produce trace information in RVFI format. This has been used for cross testing against spike and the <a href="https://github.com/CTSRD-CHERI/RVBS">RVBS</a> specification written in Bluespec SystemVerilog.</p>
<p>The C emulator can also be directly linked to Spike, which provides tandem-verification on ELF binaries (including OS boots). This is often useful in debugging OS boot issues in the model when the boot is known working on Spike. It is also useful to detect platform-specific implementation choices in Spike that are not mandated by the ISA specification.</p>
<h3 id="theorem-prover-definitions-that-support-proof">Theorem-prover definitions that support proof</h3>
<p>With Sail we aim to support the generation of idiomatic theorem prover definitions across multiple tools. At present we support Isabelle, HOL4 and Coq, and provide snapshots of the generated theorem prover definitions. Typically the verification community has been split across tool-specific lines, for example in verified compilation the CakeML project uses HOL4, seL4 uses Isabelle, and CompCert and CertiKOS use Coq. Given the broad interest in formal ISA specs among this community and others, we consider the ability to target multiple tools to be of key practical importance.</p>
<p>For the Sail RISC-V model, we currently generate definitions in HOL4, Isabelle, and Coq that are accepted by each of those tools. We have tested HOL4 Kananaskis-12, Isabelle 2018, and Coq 8.8.1.</p>
<p>For Coq, we generate definitions that preserve most of the liquid/dependent typing from the Sail specification, whereas for Isabelle and HOL4 we perform a specialised partial monomorphisation that retains useful typing information where possible yet avoids duplicating code unnecessarily.</p>
<p>Our theorem-prover translation can target multiple monads for different purposes. The first is a state monad with nondeterminism and exceptions, suitable for reasoning in a sequential setting, assuming that effectful expressions are executed without interruptions and with exclusive access to the state.</p>
<p>For reasoning about concurrency, where instructions execute out-of-order, speculatively, and non-atomically, we provide a free monad over an effect datatype of memory actions. This monad is also used as part of our aforementioned concurrency support via the RMEM tool.</p>
<h3 id="use-in-documentation">Use in documentation</h3>
<p>Latex definitions can be generated from the model that are suitable for inclusion in reference documentation. Drafts of the RISC-V <a href="https://github.com/rems-project/riscv-isa-manual/blob/sail/release/riscv-spec-sail-draft-alpha.pdf">unprivileged</a> and <a href="https://github.com/rems-project/riscv-isa-manual/blob/sail/release/riscv-privileged-sail-draft-alpha.pdf">privileged</a> specifications that include the Sail formal definitions are available in the sail branch of this <a href="https://github.com/rems-project/riscv-isa-manual/tree/sail">riscv-isa-manual repository</a>.</p>
<h3 id="use-in-test-generation">Use in test generation</h3>
<p>Our OCaml backend can produce QuickCheck-style random generators for types in Sail specifications, which we have used to produce random instructions sequences for testing. The generation of individual types can be overridden by the developer to, for example, remove implementation-specific instructions or introduce register biasing.</p>
<p>Measuring line and branch coverage of the C emulator generated from the Sail specification, the RISC-V test suite (not the new compliance suite, because it will need some setup and is mostly RV32) hits 73% (line) / 64% (branch), while the Sail-generated random tests cover 49% / 30%. This lower coverage is not a surprise: the latter currently does not generate CSR or AMO related instructions, so is presumably not hitting the memory and interrupt handling code used by these.</p>
<h3 id="use-for-concurrency-model-litmus-test-evaluation">Use for concurrency-model litmus test evaluation</h3>
<p>As part of our concurrency architecture work, we have produced and released a library of approximately 7000 <a href="https://github.com/litmus-tests/litmus-tests-riscv">litmus tests</a>. The operational and axiomatic RISC-V concurrency models are in sync for these tests, and they moreover agree with the corresponding ARM architected behaviour for the tests in common.</p>
<p>We have also run these tests on RISC-V hardware, on a SiFive RISC-V FU540 multicore proto board (Freedom Unleashed), kindly on loan from Imperas. To date, we see only sequentially consistent behaviour there.</p>
<h2 id="current-test-coverage">Current test coverage</h2>
<h3 id="risc-v-compliance-tests">RISC-V compliance tests</h3>
<p>The current compliance tests only support RV32 targets, while the Sail model covers RV64. We are working on adding RV32 support, and intend to support use in the compliance tests as a test target and as a golden model.</p>
<h3 id="os-boot-testing">OS boot testing</h3>
<p>The C and OCaml emulators have been used to boot Linux and FreeBSD up to the login prompt, including most of the standard startup scripts and programs, and the seL4 kernel running its test suite.</p>
<h3 id="concurrency-litmus-test-testing">Concurrency litmus test testing</h3>
<p>The model supports all the litmus tests mentioned above, which are the only concurrency test collection for RISC-V that we are aware of.</p>
<h3 id="other">Other</h3>
<h2 id="plans-for-future-functional-coverage">Plans for future functional coverage</h2>
<p>We plan to add support for RV32 and the F and D standard floating-point extensions, the Sv32 and Sv48 address translation modes, support for HINT encodings, PMP/PMA physical memory attributes and protection, and the N user-level interrupt standard extension. This may be followed by support for the hypervisor mode.</p>
<h2 id="plans-for-long-term-access-maintenance-etc.">Plans for long-term access, maintenance, etc.</h2>
<p>Sail is an academic project, developed from 2014 to date. It is a central part of our research infrastructure, so we expect to actively maintain it for the foreseeable future. It is open-source, BSD licenced, and developed in a public github repository.</p>
<p>The Sail RISC-V model is necessary for our research on CHERI; it is also one of the several ISA models that we aim to continue to make available in multiple theorem-prover targets, to support software and hardware verification. We thus also expect to maintain it for the foreseeable future. We may not have the resources or motivation to ourselves define every RISC-V extension in Sail, but that is properly the task of extension authors, and we would be happy to support them to do so.</p>
<h2 id="example-instructions">Example instructions</h2>
<p>These are verbatim excerpts from the main model file, <a href="https://github.com/rems-project/sail-riscv/blob/master/model/riscv.sail">riscv.sail</a>, with a few comments added.</p>
<h3 id="itype-or-addi">ITYPE (or ADDI)</h3>
<pre><code>/* the assembly abstract syntax tree (AST) clause for the ITYPE instructions */

union clause ast = ITYPE : (bits(12), regbits, regbits, iop)

/* the encode/decode mapping between AST elements and 32-bit words */

mapping encdec_iop : iop &lt;-&gt; bits(3) = {
  RISCV_ADDI  &lt;-&gt; 0b000,
  RISCV_SLTI  &lt;-&gt; 0b010,
  RISCV_SLTIU &lt;-&gt; 0b011,
  RISCV_ANDI  &lt;-&gt; 0b111,
  RISCV_ORI   &lt;-&gt; 0b110,
  RISCV_XORI  &lt;-&gt; 0b100
}

mapping clause encdec = ITYPE(imm, rs1, rd, op) &lt;-&gt; imm @ rs1 @ encdec_iop(op) @ rd @ 0b0010011

/* the execution semantics for the ITYPE instructions */

function clause execute (ITYPE (imm, rs1, rd, op)) = {
  let rs1_val = X(rs1);
  let immext : xlenbits = EXTS(imm);
  let result : xlenbits = match op {
    RISCV_ADDI  =&gt; rs1_val + immext,
    RISCV_SLTI  =&gt; EXTZ(rs1_val &lt;_s immext),
    RISCV_SLTIU =&gt; EXTZ(rs1_val &lt;_u immext),
    RISCV_ANDI  =&gt; rs1_val &amp; immext,
    RISCV_ORI   =&gt; rs1_val | immext,
    RISCV_XORI  =&gt; rs1_val ^ immext
  };
  X(rd) = result;
  true
}

/* the assembly/disassembly mapping between AST elements and strings */

mapping itype_mnemonic : iop &lt;-&gt; string = {
  RISCV_ADDI  &lt;-&gt; &quot;addi&quot;,
  RISCV_SLTI  &lt;-&gt; &quot;slti&quot;,
  RISCV_SLTIU &lt;-&gt; &quot;sltiu&quot;,
  RISCV_XORI  &lt;-&gt; &quot;xori&quot;,
  RISCV_ORI   &lt;-&gt; &quot;ori&quot;,
  RISCV_ANDI  &lt;-&gt; &quot;andi&quot;
}

mapping clause assembly = ITYPE(imm, rs1, rd, op)
                      &lt;-&gt; itype_mnemonic(op) ^ spc() ^ reg_name(rd) ^ sep() ^ reg_name(rs1) ^ sep() ^ hex_bits_12(imm)</code></pre>
<h3 id="sret">SRET</h3>
<pre><code>union clause ast = SRET : unit

mapping clause encdec = SRET() &lt;-&gt; 0b0001000 @ 0b00010 @ 0b00000 @ 0b000 @ 0b00000 @ 0b1110011

function clause execute SRET() = {
  match cur_privilege {
    User       =&gt; handle_illegal(),
    Supervisor =&gt; if   mstatus.TSR() == true
                  then handle_illegal()
                  else nextPC = handle_exception(cur_privilege, CTL_SRET(), PC),
    Machine    =&gt; nextPC = handle_exception(cur_privilege, CTL_SRET(), PC)
  };
  false
}

mapping clause assembly = SRET() &lt;-&gt; &quot;sret&quot;</code></pre>
<h2 id="documentation-for-model-and-tools">Documentation for model and tools</h2>
<p>There is a <a href="https://github.com/rems-project/sail/blob/sail2/manual.pdf">manual for Sail</a>, which describes the features of the language, provides information about the various command-line flags and targets, and contains a small tutorial for ISA description in Sail based on a two-instruction fragment of RISC-V.</p>
<h3 id="snapshot-of-reading-guide-for-those-who-just-want-to-read-it-like-an-isa-manual">snapshot of &quot;Reading Guide&quot;, for those who just want to read it like an ISA manual</h3>
<p>There are two options for a reading guide. If one intends to understand some detail of the ISA specification documents, one could use the Sail-annotated of the RISC-V architecture specifications available in the sail branch of <a href="https://github.com/rems-project/riscv-isa-manual"><code class="url">https://github.com/rems-project/riscv-isa-manual</code></a>: the <a href="https://github.com/rems-project/riscv-isa-manual/blob/sail/release/riscv-spec-sail-draft-alpha.pdf">unprivileged</a> and <a href="https://github.com/rems-project/riscv-isa-manual/blob/sail/release/riscv-privileged-sail-draft-alpha.pdf">privileged</a> specs. If one intends to understand the Sail model itself, one could use the <a href="https://github.com/rems-project/sail-riscv/blob/master/doc/ReadingGuide.md">ReadingGuide</a> provided in the model repository.</p>
<h3 id="snapshot-of-how-to-compilerun-guide-for-those-who-want-to-execute-a-model-on-programs-isa-tests-compliance-tests-other-programs">snapshot of &quot;How to Compile/Run Guide&quot; for those who want to execute a model on programs (ISA tests, Compliance tests, other programs)</h3>
<p>The documentation in the model repository provides basic instructions to compile and run the C and OCaml emulators on ELF files and OS binaries.</p>
<h3 id="snapshot-of-how-to-extend-guide-for-those-who-want-to-extend-the-model-to-capture-new-isa-extensionsexperiments.">snapshot of &quot;How to Extend Guide&quot; for those who want to extend the model to capture new ISA extensions/experiments.</h3>
<p>A <a href="https://github.com/rems-project/sail-riscv/blob/master/doc/ExtendingGuide.md">guide</a> to extending the model is provided in the repository.</p>
